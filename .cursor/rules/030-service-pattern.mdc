---
description: Service architecture and implementation patterns for the Weather Alert Service
alwaysApply: true
version: 1.1.0
lastUpdated: 2026-02-11
---

# Service Pattern Rules

## Purpose

Use consistent service-layer patterns that prioritize correctness, clarity, maintainability, and operational readiness per `000-goal.mdc`.

## Core Architecture

Prefer a simple layered design:
- HTTP handler layer: parse/validate request, map response/status
- Service layer: business logic, orchestration, decision points
- Client layer: third-party API integration and request execution
- Cache layer: read/write weather payloads with TTL
- Config/infra layer: startup wiring, dependencies, lifecycle

```text
request -> handler -> service -> (cache -> weather client) -> response
```

## Dependency Injection

Construct dependencies at startup, pass interfaces into services.

```go
type WeatherClient interface {
    GetCurrentWeather(ctx context.Context, location string) (WeatherData, error)
}

type Cache interface {
    Get(ctx context.Context, key string) (WeatherData, bool, error)
    Set(ctx context.Context, key string, value WeatherData, ttl time.Duration) error
}

type WeatherService struct {
    client WeatherClient
    cache  Cache
    ttl    time.Duration
}
```

### Rules
- Do not instantiate clients/caches inside handlers.
- Keep constructors explicit; validate required dependencies.
- Prefer interfaces at boundaries to simplify testing.

## Handler Patterns

Handlers should stay thin:
- Extract and validate path/query params
- Set/propagate request context
- Call exactly one service method for primary flow
- Translate domain errors to HTTP status codes

```go
func (h *Handler) GetWeather(w http.ResponseWriter, r *http.Request) {
    location := strings.TrimSpace(mux.Vars(r)["location"])
    if location == "" {
        writeError(w, http.StatusBadRequest, "location is required")
        return
    }

    result, err := h.weatherService.GetWeather(r.Context(), location)
    if err != nil {
        writeServiceError(w, err)
        return
    }
    writeJSON(w, http.StatusOK, result)
}
```

### Rules
- No business decision trees in handlers.
- No direct cache/client calls from handlers.
- No panic paths; always return controlled errors.

## Service Patterns

Services own orchestration and business decisions:
- Cache-first lookup
- External API fallback
- Cache population on successful fetch
- Domain-level error wrapping

```go
func (s *WeatherService) GetWeather(ctx context.Context, location string) (WeatherData, error) {
    key := normalizeLocation(location)

    if cached, ok, err := s.cache.Get(ctx, key); err == nil && ok {
        return cached, nil
    }

    data, err := s.client.GetCurrentWeather(ctx, key)
    if err != nil {
        return WeatherData{}, fmt.Errorf("fetch weather for %s: %w", key, err)
    }

    _ = s.cache.Set(ctx, key, data, s.ttl) // non-fatal write path
    return data, nil
}
```

### Rules
- Prefer explicit decision points over hidden side effects.
- Write cache on success; cache write failure should not fail request by default.
- Keep service methods deterministic and testable (per `040-testing.mdc`).

## Error Model

Use typed/sentinel domain errors and map centrally in handlers.

```go
var (
    ErrInvalidLocation = errors.New("invalid location")
    ErrUpstreamFailure = errors.New("upstream failure")
    ErrRateLimited     = errors.New("rate limited")
)
```

### Suggested status mapping
- `ErrInvalidLocation` -> `400`
- `ErrRateLimited` -> `429`
- `ErrUpstreamFailure` -> `503`
- unexpected -> `500`

### Rules
- Wrap errors with operation context (`fmt.Errorf("op: %w", err)`).
- Do not leak third-party/internal details to clients.
- Keep client-facing error body concise and stable.

## Context and Timeouts

Every downstream call must honor request context and timeout budgets.

```go
ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
defer cancel()
data, err := s.client.GetCurrentWeather(ctx, location)
```

### Rules
- No `context.Background()` in request path.
- Timeouts must be configurable.
- Propagate context through cache/client boundaries.

## Response Contract

Return a stable response shape for `/weather/{location}`:
- `temperature`
- `conditions`
- `humidity`
- `windSpeed`

### Rules
- Keep transport DTOs explicit; avoid leaking provider schema.
- Normalize units/types before returning.
- Treat missing required fields as upstream failure.

## Startup and Shutdown

App startup should:
- Load and validate configuration
- Construct logger, metrics, cache, client, services, handlers
- Register routes (`/weather/{location}`, `/health`, `/metrics`)

Shutdown should:
- Use graceful timeout
- Stop accepting new requests
- Flush logs/telemetry where possible

## Testing

Follow `040-testing.mdc` for service and handler testing patterns and requirements.

## Avoid

- Fat handlers with embedded business logic
- Global mutable state for clients/cache
- Hidden retries in multiple layers (retry amplification)
- Returning raw upstream payload/errors directly
- Tight coupling to one weather provider schema

